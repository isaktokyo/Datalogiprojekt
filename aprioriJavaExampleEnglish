package apriori;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Scanner;
import java.util.Set;

/**
 * @author GerH, 25.01.2018
 * http://bit.ly/GerhGithub
 */

public class AprioriAlgorithm {

	// HashMap that contains all sentences (as HashMaps) consisting of their words
	static HashMap<Integer, HashMap<Integer, String>> allLinesMap = new HashMap<Integer, HashMap<Integer, String>>();

	// Combinations that contains all currently allowed combinations.
	// After e.g. the 3rd iteration it contains only sets with 3 words.
	static HashMap<Integer, Set<String>> currentAllowedCombination = new HashMap<Integer, Set<String>>();
	static int currentAllowedCombinationKey=0;

	public static void main(String[] args) {

		long startTime = System.currentTimeMillis();

		int minThreshold = 3000;
		String wordSeparator = ";";
		String lineSeparator = "\n";

		String fileContent="";
		try {
			fileContent = readFile(System.getProperty("user.dir")+"\\src\\apriori\\adult.txt");
		} catch (IOException e) {
			e.printStackTrace();
		}

		String[] lines = fileContent.split(lineSeparator);
		String[] words = fileContent.replace(lineSeparator, wordSeparator).split(wordSeparator);

		// wordSet where each word occurs once (can be iterated faster; for adult.txt only 100 entries)
		Set<String> wordSet = new HashSet<String>();
		for(String word : words){
			wordSet.add(word);
		}

		// HashMap that contains HashMaps with the words of a line
		// Will be iterated later to determine how often a word occurs in the lines.
		int iterator0=0;
		for (String line : lines){
			String[] lineWords = line.split(wordSeparator);
			// Create map with sentence
			int tempIterator0=0;
			HashMap<Integer, String> sentenceWithWordMap = new HashMap<Integer, String>();
			for(String lineWord : lineWords){
				sentenceWithWordMap.put(tempIterator0, lineWord);
				tempIterator0++;
			}
			// Add sentence to allLinesMap
			allLinesMap.put(iterator0, sentenceWithWordMap);
			iterator0++;
		}

		// Set that contains the word combinations
		HashMap<Integer, Set<String>> wordMap = new HashMap<Integer, Set<String>>();

		boolean hasReturnedResults=true;
		int sizeOfWordCombinations=1; //1=one word, 2=two words, etc.

		// Output for Part 1 (“oneItems.txt”)
		String outputForOneItemsTxt="";
		String outputForPatternsTxt="";

		// Process all iterations until there are no results in an iteration
		while(hasReturnedResults){
			long startTime2 = System.currentTimeMillis();
			outputForPatternsTxt += ("Iteration " + sizeOfWordCombinations + ":\n");
			System.out.print("Iteration " + sizeOfWordCombinations + ":\n");

			hasReturnedResults=false;

			wordMap = fillMap(sizeOfWordCombinations, wordSet);
			outputForPatternsTxt += ("Possible word combinations for this iteration: " + wordMap.size() + "\n");
			System.out.print("Possible word combinations for this iteration: " + wordMap.size() + "\n");

			currentAllowedCombination.clear();
			currentAllowedCombinationKey=0;

			if(sizeOfWordCombinations==1)
				wordSet.clear();

			for(Set<String> wordCombination : wordMap.values()){

				// Count in how many lines the combination occurs
				int occurences = getNumOfOccurences(wordCombination);

				// All those that exceed the threshold are recorded
				if(occurences > minThreshold){

					// Add to text file (for now only to the String)
					if(sizeOfWordCombinations==1){
						for(String singleWord : wordCombination)
							wordSet.add(singleWord);
						outputForOneItemsTxt += (occurences + ":" + wordCombination+"\n");
					}
					outputForPatternsTxt += (occurences + ":" + wordCombination+"\n");
					System.out.print(occurences + ":" + wordCombination+"\n");

					// Add combination
					hasReturnedResults=true;
					currentAllowedCombination.put(currentAllowedCombinationKey, wordCombination);
					currentAllowedCombinationKey++;
				}
			}

			long estimatedTime2 = System.currentTimeMillis() - startTime2;
			outputForPatternsTxt += (" -> Iteration " + sizeOfWordCombinations + " took " + estimatedTime2/1000 + "." + estimatedTime2%1000 + " seconds to complete and yielded " + currentAllowedCombination.siz[...]
			System.out.print(" -> Iteration " + sizeOfWordCombinations + " took " + estimatedTime2/1000 + "." + estimatedTime2%1000 + " seconds to complete and yielded " + currentAllowedCombination.size() + " [...]

			sizeOfWordCombinations++;
		}

		long estimatedTime = System.currentTimeMillis() - startTime;
		outputForPatternsTxt += ("\nThe Apriori Algorithm finished after " + estimatedTime/1000 + "." + estimatedTime%1000 + " seconds!\n");
		System.out.print("\nThe Apriori Algorithm finished after " + estimatedTime/1000 + "." + estimatedTime%1000 + " seconds!\n");

		printTxt("oneItems", outputForOneItemsTxt);
		printTxt("patterns", outputForPatternsTxt);
	}

	// Create all possible combinations for an iteration
	private static HashMap<Integer, Set<String>> fillMap(int iteration, Set<String> words){
		int iterator=0;
		HashMap<Integer, Set<String>> returnMap = new HashMap<Integer, Set<String>>();

		if(iteration==1){
			for(String word : words){
				Set<String> currentSet = new HashSet<String>();
				currentSet.add(word);

				returnMap.put(iterator, currentSet);
				currentAllowedCombination.put(iterator, currentSet);
				iterator++;
			}
		}
		else
			for(Set<String> wordCombo : currentAllowedCombination.values()){
				for(String word : words){
					Set<String> currentSet = new HashSet<String>();
					currentSet.addAll(wordCombo);
					currentSet.add(word);

					if(currentSet.size() == iteration && !returnMap.containsValue(currentSet)){
						returnMap.put(iterator, currentSet);
						iterator++;
					}
				}
			}
		return returnMap;
	}

	private static String readFile(String path) throws IOException {
		File file = new File(path);
		StringBuilder contents = new StringBuilder((int)file.length());
		Scanner sc = new Scanner(file);
		String lineSeparator = System.getProperty("line.separator");
		try {
			while(sc.hasNextLine()) {
				contents.append(sc.nextLine() + lineSeparator);
			}
			return contents.toString();
		} finally {
			sc.close();
		}
	}

	// Returns the key for a matching value in a HashMap
	public static <T, E> T getKeyByValue(Map<T, E> map, E value) {
		for (Entry<T, E> entry : map.entrySet()) {
			if (Objects.equals(value, entry.getValue())) {
				return entry.getKey();
			}
		}
		return null;
	}

	// Check how often one or more words occur in adult.txt
	private static int getNumOfOccurences(Set<String> wordsToCheck){
		int occurences=0;
		boolean occuredInSentence = false;
		// Iterate over lines (from adult.txt)
		for(HashMap<Integer, String> oneLineMap : allLinesMap.values()){
			// Check if the searched words occur
			for(String wordToCheck : wordsToCheck){
				if(oneLineMap.containsValue(wordToCheck)){
					occuredInSentence=true;
				}
				else{
					// at least one word does not occur -> don't check this sentence further
					occuredInSentence=false;
					break;
				}

			}
			if(occuredInSentence){
				occuredInSentence=false;
				occurences++;
			}
		}

		// Return how often the word/words occur in adult.txt.
		return occurences;
	}

	// Save txt file
	private static void printTxt(String filename, String content){
		filename+=".txt";
		content=content.replace("\n]", "]");
		try(PrintWriter pr = new PrintWriter(filename)){
			pr.println(content);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
}
